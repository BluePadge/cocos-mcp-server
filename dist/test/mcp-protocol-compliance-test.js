"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const http = __importStar(require("http"));
const mcp_server_1 = require("../mcp-server");
class MockTools {
    getTools() {
        return [
            {
                name: 'echo',
                description: 'Echo args for test',
                inputSchema: {
                    type: 'object',
                    properties: {
                        fail: { type: 'boolean' },
                        value: { type: 'string' }
                    }
                }
            }
        ];
    }
    async execute(toolName, args) {
        if (toolName !== 'echo') {
            throw new Error(`Tool mock_${toolName} not found`);
        }
        if (args && args.fail) {
            return {
                success: false,
                error: 'mock failure'
            };
        }
        return {
            success: true,
            data: args
        };
    }
}
function postRaw(port, body, sessionId) {
    return new Promise((resolve, reject) => {
        const headers = {
            'Content-Type': 'application/json'
        };
        if (sessionId) {
            headers['MCP-Session-Id'] = sessionId;
        }
        const req = http.request({
            method: 'POST',
            host: '127.0.0.1',
            port,
            path: '/mcp',
            headers
        }, (res) => {
            let data = '';
            res.setEncoding('utf8');
            res.on('data', (chunk) => {
                data += chunk;
            });
            res.on('end', () => {
                resolve({
                    statusCode: res.statusCode || 0,
                    headers: res.headers,
                    body: data
                });
            });
        });
        req.on('error', reject);
        req.write(body);
        req.end();
    });
}
function parseJson(body) {
    if (!body.trim()) {
        return null;
    }
    return JSON.parse(body);
}
async function main() {
    const settings = {
        port: 0,
        autoStart: false,
        enableDebugLog: false,
        allowedOrigins: ['*'],
        maxConnections: 10
    };
    const server = new mcp_server_1.MCPServer(settings, {
        toolExecutors: {
            mock: new MockTools()
        },
        sessionIdGenerator: () => 'session-fixed'
    });
    await server.start();
    const httpServer = server.httpServer;
    const address = httpServer.address();
    const port = address.port;
    try {
        // 1. 非法 JSON => -32700
        const parseError = await postRaw(port, '{');
        assert.strictEqual(parseError.statusCode, 400);
        assert.strictEqual(parseJson(parseError.body).error.code, -32700);
        // 2. 空 batch => -32600
        const emptyBatch = await postRaw(port, '[]');
        assert.strictEqual(emptyBatch.statusCode, 200);
        assert.strictEqual(parseJson(emptyBatch.body).error.code, -32600);
        // initialize，确认返回 MCP-Session-Id
        const initialize = await postRaw(port, JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'initialize',
            params: { protocolVersion: '2025-11-25' }
        }));
        assert.strictEqual(initialize.statusCode, 200);
        const sessionId = initialize.headers['mcp-session-id'];
        assert.ok(sessionId, 'initialize 必须返回 MCP-Session-Id');
        // 7. 初始化后缺失 session header => HTTP 400
        const missingHeader = await postRaw(port, JSON.stringify({ jsonrpc: '2.0', id: 2, method: 'tools/list' }));
        assert.strictEqual(missingHeader.statusCode, 400);
        // 5. 未完成 initialized 前调用 tools/list => 生命周期错误
        const notReadyList = await postRaw(port, JSON.stringify({ jsonrpc: '2.0', id: 3, method: 'tools/list' }), sessionId);
        assert.strictEqual(notReadyList.statusCode, 200);
        assert.strictEqual(parseJson(notReadyList.body).error.code, -32600);
        // 完成 notifications/initialized
        const initializedNotification = await postRaw(port, JSON.stringify({ jsonrpc: '2.0', method: 'notifications/initialized' }), sessionId);
        assert.strictEqual(initializedNotification.statusCode, 202);
        assert.strictEqual(initializedNotification.body, '');
        // 3. 仅 notification batch => 202
        const notificationBatch = await postRaw(port, JSON.stringify([
            { jsonrpc: '2.0', method: 'notifications/progress', params: { value: 1 } },
            { jsonrpc: '2.0', method: 'notifications/custom' }
        ]), sessionId);
        assert.strictEqual(notificationBatch.statusCode, 202);
        assert.strictEqual(notificationBatch.body, '');
        // 4. request+notification 混合 batch => 仅返回 request 响应
        const mixedBatch = await postRaw(port, JSON.stringify([
            { jsonrpc: '2.0', id: 4, method: 'tools/list' },
            { jsonrpc: '2.0', method: 'notifications/progress', params: { value: 2 } }
        ]), sessionId);
        assert.strictEqual(mixedBatch.statusCode, 200);
        const mixedBody = parseJson(mixedBatch.body);
        assert.ok(Array.isArray(mixedBody));
        assert.strictEqual(mixedBody.length, 1);
        assert.strictEqual(mixedBody[0].id, 4);
        // 8. 未知方法 => -32601
        const unknownMethod = await postRaw(port, JSON.stringify({ jsonrpc: '2.0', id: 5, method: 'unknown/method' }), sessionId);
        assert.strictEqual(unknownMethod.statusCode, 200);
        assert.strictEqual(parseJson(unknownMethod.body).error.code, -32601);
        // 9. tools/call 缺少 name => -32602
        const missingName = await postRaw(port, JSON.stringify({ jsonrpc: '2.0', id: 6, method: 'tools/call', params: {} }), sessionId);
        assert.strictEqual(missingName.statusCode, 200);
        assert.strictEqual(parseJson(missingName.body).error.code, -32602);
        // 10. 工具业务失败 => result.isError = true
        const businessFailure = await postRaw(port, JSON.stringify({
            jsonrpc: '2.0',
            id: 7,
            method: 'tools/call',
            params: {
                name: 'mock_echo',
                arguments: {
                    fail: true
                }
            }
        }), sessionId);
        assert.strictEqual(businessFailure.statusCode, 200);
        const businessBody = parseJson(businessFailure.body);
        assert.strictEqual(businessBody.result.isError, true);
        console.log('mcp-protocol-compliance-test: PASS');
    }
    finally {
        server.stop();
    }
}
main().catch((error) => {
    console.error('mcp-protocol-compliance-test: FAIL');
    console.error(error);
    process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWNwLXByb3RvY29sLWNvbXBsaWFuY2UtdGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NvdXJjZS90ZXN0L21jcC1wcm90b2NvbC1jb21wbGlhbmNlLXRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQ0FBaUM7QUFDakMsMkNBQTZCO0FBRTdCLDhDQUEwQztBQUcxQyxNQUFNLFNBQVM7SUFDSixRQUFRO1FBQ1gsT0FBTztZQUNIO2dCQUNJLElBQUksRUFBRSxNQUFNO2dCQUNaLFdBQVcsRUFBRSxvQkFBb0I7Z0JBQ2pDLFdBQVcsRUFBRTtvQkFDVCxJQUFJLEVBQUUsUUFBUTtvQkFDZCxVQUFVLEVBQUU7d0JBQ1IsSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTt3QkFDekIsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRTtxQkFDNUI7aUJBQ0o7YUFDSjtTQUNKLENBQUM7SUFDTixDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFnQixFQUFFLElBQVM7UUFDNUMsSUFBSSxRQUFRLEtBQUssTUFBTSxFQUFFLENBQUM7WUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxhQUFhLFFBQVEsWUFBWSxDQUFDLENBQUM7UUFDdkQsQ0FBQztRQUVELElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNwQixPQUFPO2dCQUNILE9BQU8sRUFBRSxLQUFLO2dCQUNkLEtBQUssRUFBRSxjQUFjO2FBQ3hCLENBQUM7UUFDTixDQUFDO1FBRUQsT0FBTztZQUNILE9BQU8sRUFBRSxJQUFJO1lBQ2IsSUFBSSxFQUFFLElBQUk7U0FDYixDQUFDO0lBQ04sQ0FBQztDQUNKO0FBUUQsU0FBUyxPQUFPLENBQUMsSUFBWSxFQUFFLElBQVksRUFBRSxTQUFrQjtJQUMzRCxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMs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QztBQUVELElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO0lBQ25CLE9BQU8sQ0FBQyxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQztJQUNwRCxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3JCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEIsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCAqIGFzIGh0dHAgZnJvbSAnaHR0cCc7XG5pbXBvcnQgeyBBZGRyZXNzSW5mbyB9IGZyb20gJ25ldCc7XG5pbXBvcnQgeyBNQ1BTZXJ2ZXIgfSBmcm9tICcuLi9tY3Atc2VydmVyJztcbmltcG9ydCB7IE1DUFNlcnZlclNldHRpbmdzLCBUb29sRGVmaW5pdGlvbiB9IGZyb20gJy4uL3R5cGVzJztcblxuY2xhc3MgTW9ja1Rvb2xzIHtcbiAgICBwdWJsaWMgZ2V0VG9vbHMoKTogVG9vbERlZmluaXRpb25bXSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2VjaG8nLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRWNobyBhcmdzIGZvciB0ZXN0JyxcbiAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbDogeyB0eXBlOiAnYm9vbGVhbicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IHR5cGU6ICdzdHJpbmcnIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZXhlY3V0ZSh0b29sTmFtZTogc3RyaW5nLCBhcmdzOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBpZiAodG9vbE5hbWUgIT09ICdlY2hvJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb29sIG1vY2tfJHt0b29sTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncyAmJiBhcmdzLmZhaWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdtb2NrIGZhaWx1cmUnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiBhcmdzXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5pbnRlcmZhY2UgSHR0cFJlc3VsdCB7XG4gICAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICAgIGhlYWRlcnM6IGh0dHAuSW5jb21pbmdIdHRwSGVhZGVycztcbiAgICBib2R5OiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHBvc3RSYXcocG9ydDogbnVtYmVyLCBib2R5OiBzdHJpbmcsIHNlc3Npb25JZD86IHN0cmluZyk6IFByb21pc2U8SHR0cFJlc3VsdD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHNlc3Npb25JZCkge1xuICAgICAgICAgICAgaGVhZGVyc1snTUNQLVNlc3Npb24tSWQnXSA9IHNlc3Npb25JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlcSA9IGh0dHAucmVxdWVzdChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBob3N0OiAnMTI3LjAuMC4xJyxcbiAgICAgICAgICAgICAgICBwb3J0LFxuICAgICAgICAgICAgICAgIHBhdGg6ICcvbWNwJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgICAgICAgICAgcmVzLnNldEVuY29kaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgcmVzLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgKz0gY2h1bms7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzLnN0YXR1c0NvZGUgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICByZXEub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgcmVxLndyaXRlKGJvZHkpO1xuICAgICAgICByZXEuZW5kKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSnNvbihib2R5OiBzdHJpbmcpOiBhbnkge1xuICAgIGlmICghYm9keS50cmltKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBtYWluKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNldHRpbmdzOiBNQ1BTZXJ2ZXJTZXR0aW5ncyA9IHtcbiAgICAgICAgcG9ydDogMCxcbiAgICAgICAgYXV0b1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgZW5hYmxlRGVidWdMb2c6IGZhbHNlLFxuICAgICAgICBhbGxvd2VkT3JpZ2luczogWycqJ10sXG4gICAgICAgIG1heENvbm5lY3Rpb25zOiAxMFxuICAgIH07XG5cbiAgICBjb25zdCBzZXJ2ZXIgPSBuZXcgTUNQU2VydmVyKHNldHRpbmdzLCB7XG4gICAgICAgIHRvb2xFeGVjdXRvcnM6IHtcbiAgICAgICAgICAgIG1vY2s6IG5ldyBNb2NrVG9vbHMoKVxuICAgICAgICB9LFxuICAgICAgICBzZXNzaW9uSWRHZW5lcmF0b3I6ICgpID0+ICdzZXNzaW9uLWZpeGVkJ1xuICAgIH0pO1xuXG4gICAgYXdhaXQgc2VydmVyLnN0YXJ0KCk7XG5cbiAgICBjb25zdCBodHRwU2VydmVyOiBodHRwLlNlcnZlciA9IChzZXJ2ZXIgYXMgYW55KS5odHRwU2VydmVyO1xuICAgIGNvbnN0IGFkZHJlc3MgPSBodHRwU2VydmVyLmFkZHJlc3MoKSBhcyBBZGRyZXNzSW5mbztcbiAgICBjb25zdCBwb3J0ID0gYWRkcmVzcy5wb3J0O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gMS4g6Z2e5rOVIEpTT04gPT4gLTMyNzAwXG4gICAgICAgIGNvbnN0IHBhcnNlRXJyb3IgPSBhd2FpdCBwb3N0UmF3KHBvcnQsICd7Jyk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChwYXJzZUVycm9yLnN0YXR1c0NvZGUsIDQwMCk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChwYXJzZUpzb24ocGFyc2VFcnJvci5ib2R5KS5lcnJvci5jb2RlLCAtMzI3MDApO1xuXG4gICAgICAgIC8vIDIuIOepuiBiYXRjaCA9PiAtMzI2MDBcbiAgICAgICAgY29uc3QgZW1wdHlCYXRjaCA9IGF3YWl0IHBvc3RSYXcocG9ydCwgJ1tdJyk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChlbXB0eUJhdGNoLnN0YXR1c0NvZGUsIDIwMCk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChwYXJzZUpzb24oZW1wdHlCYXRjaC5ib2R5KS5lcnJvci5jb2RlLCAtMzI2MDApO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemXvvIznoa7orqTov5Tlm54gTUNQLVNlc3Npb24tSWRcbiAgICAgICAgY29uc3QgaW5pdGlhbGl6ZSA9IGF3YWl0IHBvc3RSYXcoXG4gICAgICAgICAgICBwb3J0LFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2luaXRpYWxpemUnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogeyBwcm90b2NvbFZlcnNpb246ICcyMDI1LTExLTI1JyB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoaW5pdGlhbGl6ZS5zdGF0dXNDb2RlLCAyMDApO1xuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBpbml0aWFsaXplLmhlYWRlcnNbJ21jcC1zZXNzaW9uLWlkJ10gYXMgc3RyaW5nO1xuICAgICAgICBhc3NlcnQub2soc2Vzc2lvbklkLCAnaW5pdGlhbGl6ZSDlv4Xpobvov5Tlm54gTUNQLVNlc3Npb24tSWQnKTtcblxuICAgICAgICAvLyA3LiDliJ3lp4vljJblkI7nvLrlpLEgc2Vzc2lvbiBoZWFkZXIgPT4gSFRUUCA0MDBcbiAgICAgICAgY29uc3QgbWlzc2luZ0hlYWRlciA9IGF3YWl0IHBvc3RSYXcoXG4gICAgICAgICAgICBwb3J0LFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyBqc29ucnBjOiAnMi4wJywgaWQ6IDIsIG1ldGhvZDogJ3Rvb2xzL2xpc3QnIH0pXG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChtaXNzaW5nSGVhZGVyLnN0YXR1c0NvZGUsIDQwMCk7XG5cbiAgICAgICAgLy8gNS4g5pyq5a6M5oiQIGluaXRpYWxpemVkIOWJjeiwg+eUqCB0b29scy9saXN0ID0+IOeUn+WRveWRqOacn+mUmeivr1xuICAgICAgICBjb25zdCBub3RSZWFkeUxpc3QgPSBhd2FpdCBwb3N0UmF3KFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsganNvbnJwYzogJzIuMCcsIGlkOiAzLCBtZXRob2Q6ICd0b29scy9saXN0JyB9KSxcbiAgICAgICAgICAgIHNlc3Npb25JZFxuICAgICAgICApO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwobm90UmVhZHlMaXN0LnN0YXR1c0NvZGUsIDIwMCk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChwYXJzZUpzb24obm90UmVhZHlMaXN0LmJvZHkpLmVycm9yLmNvZGUsIC0zMjYwMCk7XG5cbiAgICAgICAgLy8g5a6M5oiQIG5vdGlmaWNhdGlvbnMvaW5pdGlhbGl6ZWRcbiAgICAgICAgY29uc3QgaW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSBhd2FpdCBwb3N0UmF3KFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsganNvbnJwYzogJzIuMCcsIG1ldGhvZDogJ25vdGlmaWNhdGlvbnMvaW5pdGlhbGl6ZWQnIH0pLFxuICAgICAgICAgICAgc2Vzc2lvbklkXG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChpbml0aWFsaXplZE5vdGlmaWNhdGlvbi5zdGF0dXNDb2RlLCAyMDIpO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoaW5pdGlhbGl6ZWROb3RpZmljYXRpb24uYm9keSwgJycpO1xuXG4gICAgICAgIC8vIDMuIOS7hSBub3RpZmljYXRpb24gYmF0Y2ggPT4gMjAyXG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbkJhdGNoID0gYXdhaXQgcG9zdFJhdyhcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgeyBqc29ucnBjOiAnMi4wJywgbWV0aG9kOiAnbm90aWZpY2F0aW9ucy9wcm9ncmVzcycsIHBhcmFtczogeyB2YWx1ZTogMSB9IH0sXG4gICAgICAgICAgICAgICAgeyBqc29ucnBjOiAnMi4wJywgbWV0aG9kOiAnbm90aWZpY2F0aW9ucy9jdXN0b20nIH1cbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgc2Vzc2lvbklkXG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChub3RpZmljYXRpb25CYXRjaC5zdGF0dXNDb2RlLCAyMDIpO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwobm90aWZpY2F0aW9uQmF0Y2guYm9keSwgJycpO1xuXG4gICAgICAgIC8vIDQuIHJlcXVlc3Qrbm90aWZpY2F0aW9uIOa3t+WQiCBiYXRjaCA9PiDku4Xov5Tlm54gcmVxdWVzdCDlk43lupRcbiAgICAgICAgY29uc3QgbWl4ZWRCYXRjaCA9IGF3YWl0IHBvc3RSYXcoXG4gICAgICAgICAgICBwb3J0LFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgICAgICAgIHsganNvbnJwYzogJzIuMCcsIGlkOiA0LCBtZXRob2Q6ICd0b29scy9saXN0JyB9LFxuICAgICAgICAgICAgICAgIHsganNvbnJwYzogJzIuMCcsIG1ldGhvZDogJ25vdGlmaWNhdGlvbnMvcHJvZ3Jlc3MnLCBwYXJhbXM6IHsgdmFsdWU6IDIgfSB9XG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHNlc3Npb25JZFxuICAgICAgICApO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwobWl4ZWRCYXRjaC5zdGF0dXNDb2RlLCAyMDApO1xuICAgICAgICBjb25zdCBtaXhlZEJvZHkgPSBwYXJzZUpzb24obWl4ZWRCYXRjaC5ib2R5KTtcbiAgICAgICAgYXNzZXJ0Lm9rKEFycmF5LmlzQXJyYXkobWl4ZWRCb2R5KSk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChtaXhlZEJvZHkubGVuZ3RoLCAxKTtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKG1peGVkQm9keVswXS5pZCwgNCk7XG5cbiAgICAgICAgLy8gOC4g5pyq55+l5pa55rOVID0+IC0zMjYwMVxuICAgICAgICBjb25zdCB1bmtub3duTWV0aG9kID0gYXdhaXQgcG9zdFJhdyhcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IGpzb25ycGM6ICcyLjAnLCBpZDogNSwgbWV0aG9kOiAndW5rbm93bi9tZXRob2QnIH0pLFxuICAgICAgICAgICAgc2Vzc2lvbklkXG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbCh1bmtub3duTWV0aG9kLnN0YXR1c0NvZGUsIDIwMCk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChwYXJzZUpzb24odW5rbm93bk1ldGhvZC5ib2R5KS5lcnJvci5jb2RlLCAtMzI2MDEpO1xuXG4gICAgICAgIC8vIDkuIHRvb2xzL2NhbGwg57y65bCRIG5hbWUgPT4gLTMyNjAyXG4gICAgICAgIGNvbnN0IG1pc3NpbmdOYW1lID0gYXdhaXQgcG9zdFJhdyhcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IGpzb25ycGM6ICcyLjAnLCBpZDogNiwgbWV0aG9kOiAndG9vbHMvY2FsbCcsIHBhcmFtczoge30gfSksXG4gICAgICAgICAgICBzZXNzaW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKG1pc3NpbmdOYW1lLnN0YXR1c0NvZGUsIDIwMCk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChwYXJzZUpzb24obWlzc2luZ05hbWUuYm9keSkuZXJyb3IuY29kZSwgLTMyNjAyKTtcblxuICAgICAgICAvLyAxMC4g5bel5YW35Lia5Yqh5aSx6LSlID0+IHJlc3VsdC5pc0Vycm9yID0gdHJ1ZVxuICAgICAgICBjb25zdCBidXNpbmVzc0ZhaWx1cmUgPSBhd2FpdCBwb3N0UmF3KFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBpZDogNyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICd0b29scy9jYWxsJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21vY2tfZWNobycsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzZXNzaW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGJ1c2luZXNzRmFpbHVyZS5zdGF0dXNDb2RlLCAyMDApO1xuICAgICAgICBjb25zdCBidXNpbmVzc0JvZHkgPSBwYXJzZUpzb24oYnVzaW5lc3NGYWlsdXJlLmJvZHkpO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoYnVzaW5lc3NCb2R5LnJlc3VsdC5pc0Vycm9yLCB0cnVlKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnbWNwLXByb3RvY29sLWNvbXBsaWFuY2UtdGVzdDogUEFTUycpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNlcnZlci5zdG9wKCk7XG4gICAgfVxufVxuXG5tYWluKCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcignbWNwLXByb3RvY29sLWNvbXBsaWFuY2UtdGVzdDogRkFJTCcpO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbn0pO1xuIl19